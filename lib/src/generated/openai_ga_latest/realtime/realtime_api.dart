// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, unused_import, invalid_annotation_target, unnecessary_import

import 'dart:convert';
import 'package:dio/dio.dart' hide Headers;
import 'package:retrofit/retrofit.dart';
import 'package:retrofit/error_logger.dart';

import '../models/realtime_call_refer_request.dart';
import '../models/realtime_call_reject_request.dart';
import '../models/realtime_create_client_secret_request.dart';
import '../models/realtime_create_client_secret_response.dart';
import '../models/realtime_session_create_request.dart';
import '../models/realtime_session_create_request_ga.dart';
import '../models/realtime_session_create_response.dart';
import '../models/realtime_transcription_session_create_request.dart';
import '../models/realtime_transcription_session_create_response.dart';

part 'realtime_api.g.dart';

@RestApi()
abstract class RealtimeApi {
  factory RealtimeApi(Dio dio, {String? baseUrl}) = _RealtimeApi;

  /// Create call.
  ///
  /// Create a new Realtime API call over WebRTC and receive the SDP answer needed.
  /// to complete the peer connection.
  ///
  /// [sdp] - WebRTC Session Description Protocol (SDP) offer generated by the caller.
  ///
  /// [session] - Optional session configuration to apply before the realtime session is.
  /// created. Use the same parameters you would send in a [`create client secret`](https://platform.openai.com/docs/api-reference/realtime-sessions/create-realtime-client-secret).
  /// request.
  @MultiPart()
  @POST('/realtime/calls')
  Future<HttpResponse<String>> createRealtimeCall({
    @Part(name: 'sdp') required String sdp,
    @Part(name: 'session') RealtimeSessionCreateRequestGa? session,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Accept call.
  ///
  /// Accept an incoming SIP call and configure the realtime session that will.
  /// handle it.
  ///
  /// [callId] - The identifier for the call provided in the.
  /// [`realtime.call.incoming`](https://platform.openai.com/docs/api-reference/webhook-events/realtime/call/incoming).
  /// webhook.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/calls/{call_id}/accept')
  Future<HttpResponse<void>> acceptRealtimeCall({
    @Path('call_id') required String callId,
    @Body() required RealtimeSessionCreateRequestGa body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Hang up call.
  ///
  /// End an active Realtime API call, whether it was initiated over SIP or.
  /// WebRTC.
  ///
  /// [callId] - The identifier for the call. For SIP calls, use the value provided in the.
  /// [`realtime.call.incoming`](https://platform.openai.com/docs/api-reference/webhook-events/realtime/call/incoming).
  /// webhook. For WebRTC sessions, reuse the call ID returned in the `Location`.
  /// header when creating the call with.
  /// [`POST /v1/realtime/calls`](https://platform.openai.com/docs/api-reference/realtime/create-call).
  @POST('/realtime/calls/{call_id}/hangup')
  Future<HttpResponse<void>> hangupRealtimeCall({
    @Path('call_id') required String callId,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Refer call.
  ///
  /// Transfer an active SIP call to a new destination using the SIP REFER verb.
  ///
  /// [callId] - The identifier for the call provided in the.
  /// [`realtime.call.incoming`](https://platform.openai.com/docs/api-reference/webhook-events/realtime/call/incoming).
  /// webhook.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/calls/{call_id}/refer')
  Future<HttpResponse<void>> referRealtimeCall({
    @Path('call_id') required String callId,
    @Body() required RealtimeCallReferRequest body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Reject call.
  ///
  /// Decline an incoming SIP call by returning a SIP status code to the caller.
  ///
  /// [callId] - The identifier for the call provided in the.
  /// [`realtime.call.incoming`](https://platform.openai.com/docs/api-reference/webhook-events/realtime/call/incoming).
  /// webhook.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/calls/{call_id}/reject')
  Future<HttpResponse<void>> rejectRealtimeCall({
    @Path('call_id') required String callId,
    @Body() RealtimeCallRejectRequest? body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Create client secret.
  ///
  /// Create a Realtime client secret with an associated session configuration.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/client_secrets')
  Future<HttpResponse<RealtimeCreateClientSecretResponse>> createRealtimeClientSecret({
    @Body() required RealtimeCreateClientSecretRequest body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Create session.
  ///
  /// Create an ephemeral API token for use in client-side applications with the.
  /// Realtime API. Can be configured with the same session parameters as the.
  /// `session.update` client event.
  ///
  /// It responds with a session object, plus a `client_secret` key which contains.
  /// a usable ephemeral API token that can be used to authenticate browser clients.
  /// for the Realtime API.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/sessions')
  Future<HttpResponse<RealtimeSessionCreateResponse>> createRealtimeSession({
    @Body() required RealtimeSessionCreateRequest body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });

  /// Create transcription session.
  ///
  /// Create an ephemeral API token for use in client-side applications with the.
  /// Realtime API specifically for realtime transcriptions. .
  /// Can be configured with the same session parameters as the `transcription_session.update` client event.
  ///
  /// It responds with a session object, plus a `client_secret` key which contains.
  /// a usable ephemeral API token that can be used to authenticate browser clients.
  /// for the Realtime API.
  ///
  /// [body] - Name not received - field will be skipped.
  @POST('/realtime/transcription_sessions')
  Future<HttpResponse<RealtimeTranscriptionSessionCreateResponse>> createRealtimeTranscriptionSession({
    @Body() required RealtimeTranscriptionSessionCreateRequest body,
    @Extras() Map<String, dynamic>? extras,
    @DioOptions() RequestOptions? options,
  });
}
